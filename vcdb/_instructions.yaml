
function_lists:
  condition_passed:
    brief: Condition Codes
    desc: |
      TBD
    return_type: int
    parameters: int
    type: int (*condition_passed[])(int)
    entries:
      - name: eq
        brief: Equal
        suffix: eq
        code_name: eq
        code: |
          int eq(int status) {
              return Z(status);
          }
      - name: ne
        brief: Not Equal
        suffix: ne
        code: |
          int ne(int status) {
              return !Z(status);
          }
      - name: cs
        brief: Carry Set
        desc: Unsigned less
        suffix: cs/lo
        code: |
          int cs(int status) {
              return C(status);
          }
      - name: cc
        brief: Carry Clear
        desc: Unsigned greater or equal
        suffix: cc/hs
        code: |
          int cc(int status) {
              return !C(status);
          }
      - name: mi
        brief: Negative Set
        suffix: mi
        code: |
          int mi(int status) {
              return N(status);
          }
      - name: pl
        brief: Negative Clear
        suffix: pl
        code: |
          int pl(int status) {
              return !N(status);
          }
      - name: vs
        brief: Overflow Set
        suffix: vs
        code: |
          int vs(int status) {
              return V(status);
          }
      - name: vc
        brief: Overflow Clear 
        suffix: vc
        code: |
          int vc(int status) {
              return !V(status);
          }
      - name: hi
        brief: Unsigned Greater
        suffix: hi
        code: |
          int hi(int status) {
              return !C(status) && !Z(status);
          }
      - name: ls
        brief: Unsigned Less or Equal
        suffix: ls
        code: |
          int ls(int status) {
              return C(status) || Z(status);
          }
      - name: ge
        brief: Signed Greater or Equal
        suffix: ge
        code: |
          int ge(int status) {
              return N(status) == V(status);
          }
      - name: lt
        brief: Signed Less Than
        suffix: lt
        code: |
          int lt(int status) {
              return N(status) != V(status);
          }
      - name: gt
        brief: Signed Greater
        suffix: gt
        code: |
          int gt(int status) {
              return N(status) == V(status) && !Z(status);
          }
      - name: le
        brief: Signed Less or Equal
        suffix: le
        code: |
          int le(int status) {
              return N(status) != V(status) || Z(status);
          }
      - name: always
        brief: Always
        code: |
          int always(int status) {
              return 1;
          }
      - name: never
        brief: Never
        suffix: f
        code: |
          int never(int status) {
              return 0;
          }
  scalar_op:
    brief: Scalar Binary Arithmetic/Logical Operations
    desc: |
      TBD
    return_type: void
    parameters: uint32_t*, int32_t, int32_t
    entries:
      - name: mov
        brief: Move
        code_name: mov
        code: |
          void mov(uint32_t *dest, int32_t a, int32_t b) {
              *dest = b;
          }
      - name: cmn
        brief: Compare By Addition
        code_name: cmn
        code: |
          void cmn(uint32_t *dest, int32_t a, int32_t b) {
              sr = (sr & ~0xf) | condition_flags((int64_t)a + b);
          }
      - name: add
        brief: Addition
        code_name: add
        code: |
          void add(uint32_t *dest, int32_t a, int32_t b) {
              *dest = a + b;
          }
      - name: bic
        brief: Bit Clear
        code_name: bic
        code: |
          void bic(uint32_t *dest, int32_t a, int32_t b) {
              *dest = a & ~b;
          }
      - name: mul
        brief: Multiply
        code_name: mul
        code: |
          void mul(uint32_t *dest, int32_t a, int32_t b) {
              *dest = a * b;
          }
      - name: eor
        brief: Exclusive Or
        code_name: eor
        code: |
          void eor(uint32_t *dest, int32_t a, int32_t b) {
              *dest = a ^ b;
          }
      - name: sub
        brief: Subtraction
        code_name: sub
        code: |
          void sub(uint32_t *dest, int32_t a, int32_t b) {
              *dest = a - b;
          }
      - name: and
        brief: And
        code_name: and
        code: |
          void and(uint32_t *dest, int32_t a, int32_t b) {
              *dest = a & b;
          }
      - name: mvn
        brief: Not
        code_name: mvn
        code: |
          void mvn(uint32_t *dest, int32_t a, int32_t b) {
              *dest = ~b;
          }
      - name: ror
        brief: Rotate Right
        code_name: ror
        code: |
          void ror(uint32_t *dest, int32_t a, int32_t b) {
              *dest = (a >> b) | (a << (32 - b));
          }
      - name: cmp
        brief: Compare
        code_name: cmp
        code: |
          void cmp(uint32_t *dest, int32_t a, int32_t b) {
              sr = (sr & ~0xf) | condition_flags((int64_t)a - b);
          }
      - name: rsb
        brief: Reverse Subtract
        code_name: rsb
        code: |
          void rsb(uint32_t *dest, int32_t a, int32_t b) {
              *dest = b - a;
          }
      - name: btst
        brief: Bit Test
        code_name: btst
        code: |
          void btst(uint32_t *dest, int32_t a, int32_t b) {
              sr |= 0x8;
              if (a & (1 << b)) {
                  sr &= ~0x8;
              }
          }
      - name: or
        brief: Or
        code_name: or
        code: |
          void or(uint32_t *dest, int32_t a, int32_t b) {
              *dest = a | b;
          }
      - name: extu
        brief: Mask Leftmost Bits
        code_name: extu
        code: |
          void extu(uint32_t *dest, int32_t a, int32_t b) {
              *dest = a & ((1 << b) - 1);
          }
      - name: max
        brief: Maximum
        code_name: max
        code: |
          void max(uint32_t *dest, int32_t a, int32_t b) {
              *dest = a > b ? a : b;
          }
      - name: bset
        brief: Bit Set
        code_name: bset
        code: |
          void bset(uint32_t *dest, int32_t a, int32_t b) {
              *dest = a | (1 << b);
          }
      - name: min
        brief: Min
        code_name: min
        code: |
          void min(uint32_t *dest, int32_t a, int32_t b) {
              *dest = a < b ? a : b;
          }
      - name: bclr
        brief: Bit Clear
        code_name: bclr
        code: |
          void bclr(uint32_t *dest, int32_t a, int32_t b) {
              *dest = a & ~(1 << b);
          }
      - name: adds2
        brief: Add Scaled by 2
        code_name: adds2
        code: |
          void adds2(uint32_t *dest, int32_t a, int32_t b) {
              *dest = a + b * 2;
          }
      - name: bchg
        brief: Bit Toggle
        code_name: bchg
        code: |
          void bchg(uint32_t *dest, int32_t a, int32_t b) {
              *dest = a ^ (1 << b);
          }
      - name: adds4
        brief: Add Scaled by 4
        code_name: adds4
        code: |
          void adds4(uint32_t *dest, int32_t a, int32_t b) {
              *dest = a + b * 4;
          }
      - name: adds8
        brief: Add Scaled by 8
        code_name: adds8
        code: |
          void adds8(uint32_t *dest, int32_t a, int32_t b) {
              *dest = a + b * 8;
          }
      - name: adds16
        brief: Add Scaled by 16
        code_name: adds16
        code: |
          void adds16(uint32_t *dest, int32_t a, int32_t b) {
              *dest = a + b * 16;
          }
      - name: exts
        brief: Sign Extend
        code_name: exts
        code: |
          void exts(uint32_t *dest, int32_t a, int32_t b) {
              *dest = sign_extend(a, b);
          }
      - name: neg
        brief: Negate
        code_name: neg
        code: |
          void neg(uint32_t *dest, int32_t a, int32_t b) {
              *dest = -b;
          }
      - name: lsr
        brief: Logical Shift Right
        code_name: lsr
        code: |
          void lsr(uint32_t *dest, int32_t a, int32_t b) {
              *dest = (uint32_t)a >> b;
          }
      - name: clz
        brief: Count Leading Zeros
        code_name: clz
        code: |
          void clz(uint32_t *dest, int32_t a, int32_t b) {
              error("Not implemented!");
              /* TODO */
          }
      - name: lsl
        brief: Logical Shift Left
        code_name: lsl
        code: |
          void lsl(uint32_t *dest, int32_t a, int32_t b) {
              *dest = a << b;
          }
      - name: brev
        brief: Bit Reverse
        code_name: brev
        code: |
          void brev(uint32_t *dest, int32_t a, int32_t b) {
              error("Not implemented!");
              /* TODO */
          }
      - name: asr
        brief: Arithmetic Shift Right
        code_name: asr
        code: |
          void asr(uint32_t *dest, int32_t a, int32_t b) {
              if (a && 0x80000000) {
                  *dest = (a >> b) | ~(0xffffffffu >> b);
              } else {
                  *dest = a >> b;
              }  
          }
      - name: _abs
        brief: Absolute Value
        code_name: abs
        code: |
          void _abs(uint32_t *dest, int32_t a, int32_t b) {
              if (b < 0) {
                  *dest = -b;
              } else {
                  *dest = b;
              }
          }
  float_op:
    name: Scalar Floating Point Operations
    desc: |
      TBD
    return_type: void
    parameters: float*, float, float
    entries:
      - name: fadd
        brief: Add
        code_name: fadd
        code: |
          void fadd(float *dest, float a, float b) {
              *dest = a + b;
          }
      - name: fsub
        brief: Subtract
        code_name: fsub
        code: |
          void fsub(float *dest, float a, float b) {
              *dest = a - b;
          }
      - name: fmul
        brief: Multiply
        code_name: fmul
        code: |
          void fmul(float *dest, float a, float b) {
              *dest = a * b;
          }
      - name: fdiv
        brief: Divide
        code_name: fdiv
        code: |
          void fdiv(float *dest, float a, float b) {
              // TODO: division through 0?
              *dest = a / b;
          }
      - name: fcmp
        brief: Compare
        code_name: fcmp
        code: |
          void fcmp(float *dest, float a, float b) {
              error("TBD");
          }
      - name: _fabs
        brief: Absolute Value
        code_name: fabs
        code: |
          void _fabs(float *dest, float a, float b) {
              *dest = fabs(b);
          }
      - name: frsb
        brief: Reverse Subtract
        code_name: frsb
        code: |
          void frsb(float *dest, float a, float b) {
              *dest = b - 1;
          }
      - name: _fmax
        brief: Maximum
        code_name: fmax
        code: |
          void _fmax(float *dest, float a, float b) {
              *dest = a > b ? a : b;
          }
      - name: frcp
        brief: Reciprocal
        code_name: frcp
        code: |
          void frcp(float *dest, float a, float b) {
              *dest = 1.0f / b;
          }
      - name: frsqrt
        brief: Reciprocal Square Root
        code_name: frsqrt
        code: |
          void frsqrt(float *dest, float a, float b) {
              *dest = 1.0f / sqrt(b);
          }
      - name: fnmul
        brief: Negated Multiply
        code_name: fnmul
        code: |
          void fnmul(float *dest, float a, float b) {
              *dest = -(a * b);
          }
      - name: _fmin
        brief: Minimum
        code_name: fmin
        code: |
          void _fmin(float *dest, float a, float b) {
              *dest = a < b ? a : b;
          }
      - name: fld0
        brief: Load Zero
        code_name: fld0
        code: |
          void fld0(float *dest, float a, float b) {
              *dest = 0.0f;
          }
      - name: fld1
        brief: Load One
        code_name: fld1
        code: |
          void fld1(float *dest, float a, float b) {
              *dest = 1.0f;
          }
      - name: fop14
        brief: Unknown Operation 14
        code_name: fop14
        code: |
          void fop14(float *dest, float a, float b) {
              error("TBD");
          }
      - name: fop14
        brief: Unknown Operation 15
        code_name: fop14
        code: |
          void fop15(float *dest, float a, float b) {
              error("TBD");
          }
  vector_op:
    name: Vector Binary Arithmetic/Logical Operations

instructions:
  # 16-bit instructions
  - name: nop
    pattern: 0000 0000 0000 0001
  - name: wait
    pattern: 0000 0000 0000 0010
  - name: user
    pattern: 0000 0000 0000 0011
  - name: enable
    pattern: 0000 0000 0000 0100
    code: |
      sr |= 1 << 30;
  - name: disable
    pattern: 0000 0000 0000 0101
    code: |
      sr |= ~(1 << 30);
  - name: clr
    pattern: 0000 0000 0000 0110
    code: |
      sr &= ~0x30;
  - name: inc
    pattern: 0000 0000 0000 0111
    code: |
      sr = ((sr & 0x30) + 0x10) & 0x30;
  - name: chg
    pattern: 0000 0000 0000 1000
    code: |
      sr ^= 0x20;
  - name: dec
    pattern: 0000 0000 0000 1001
    code: |
      sr = ((sr & 0x30) - 0x10) & 0x30;
  - name: rti
    pattern: 0000 0000 0000 1010
    code: |
      sr = pop();
      pc = pop() - 2;
  - name: swi Rd
    pattern: 0000 0000 001 Rd:5
    code: |
      interrupt(0x20 + (Rd & 0x31), "swi");
  - name: b Rd
    pattern: 0000 0000 010 Rd:5
    code: |
      pc = Rd - 2;
  - name: b Rd
    pattern: 0000 0000 011 Rd:5
    code: |
      lr = pc + 2;
      pc = Rd - 2;
  - name: tbb Rd
    pattern: 0000 0000 100 Rd:5
    code: |
      error("TBD");
  - name: tbb Rd
    pattern: 0000 0000 101 Rd:5
    code: |
      error("TBD");
  - name: mov Rd, cpuid
    pattern: 0000 0000 111 Rd:5
    code: |
      // TODO: compute the proper coreid
      Rd = 0x04000104;
  - name: swi imm
    pattern: 0000 0001 11 imm:6
    code: |
      interrupt(0x20 + (imm & 31), "swi");
  # TODO: push/pop with only pc/lr
  - name: push
    pattern: 0000 001 with_lr:1 1 first:2 count:5
    code: |
      int first_register[] = {0, 6, 18, 24};
      int i;
      uint32_t old_sp = sp;
      if (with_lr) {
          count = (count + 1) & 31;
      } else {
          count = count + 1;
      }
      for (i = 0; i < count; i++) {
          int reg_index = (first_register[first] + i) & 31;
          if (reg_index == 25) {
              push(old_sp);
          } else {
              push(reg[reg_index]);
          }
      }
      if (with_lr) {
          push(lr);
      }
  - name: pop
    pattern: 0000 001 with_pc:1 0 first:2 count:5
    code: |
      int first_register[] = {0, 6, 18, 24};
      int i;
      uint32_t next_sp;
      if (with_pc) {
          count = (count + 1) & 31;
      } else {
          count = count + 1;
      }
      next_sp = sp + (count + with_pc) * 4;
      if (with_pc) {
          pc = pop() - 2;
      }
      // TODO: push/pop order?
      for (i = count - 1; i >= 0; i--) {
          int reg_index = (first_register[first] + i) & 31;
          if (reg_index == 31) {
              // pc is not popped from the stack!
              sp = sp + 4;
          } else if (reg_index == 25) {
              next_sp = pop();
          } else {
              regs[reg_index] = pop();
          }
      }
      sp = next_sp;
  - name: ld Rd, offset(sp)
    pattern: 0000 010 offset:5 Rd:4
    code: |
      Rd = load(sp + sign_extend_5(offset) * 4, WORD);
  - name: st Rd, offset(sp)
    pattern: 0000 011 offset:5 Rd:4
    code: |
      store(sp + sign_extend_5(offset) * 4, WORD, Rd);
  - name: ld<size> Rd, (Rs)
    pattern: 0000 1 format:2 0 Rs:4 Rd:4
    code: |
      Rd = load(Rs, format);
  - name: st<size> Rd, (Rs)
    pattern: 0000 1 format:2 1 Rs:4 Rd:4
    code: |
      store(Rs, format, Rd);
  - name: lea Rd, 4*imm(sp)
    pattern: 0001 0 imm:6 Rd:5
    code: |
      Rd = sp + 4 * sign_extend(imm, 6);
  - name: b<cond> offset
    pattern: 0001 1 cond:4 offset:7
    code: |
      if (condition_passed(cond, sr)) {
        pc = (pc - 2) + sign_extend_7(offset) * 2;
      }
  - name: ld Rd, 4*imm(Rs)
    pattern: 0010 imm:4 Rs:4 Rd:4
    code: |
      Rs = load(Rs + sign_extend(imm, 4) * 4, WORD);
  - name: st Rd, 4*imm(Rs)
    pattern: 0011 imm:4 Rs:4 Rd:4
    code: |
      store(Rs + sign_extend(imm, 4) * 4, WORD, Rd);
  # TODO: What about add+shl?
  - name: <op> Rd, Rs
    pattern: 010 op:5 Rs:4 Rd:4
    code: |
      scalar_op(op, &Rd, Rd, Rs);
  - name: <op> Rd, imm
    pattern: 011 op:4 imm:5 Rd:4
    code: |
      scalar_op(op * 2, &Rd, Rd, sign_extend_5(imm));

  # 32-bit branch instructions
  - name: addcmpb<cond> Rd, Ra, Rs, 2*offset + pc
    pattern: 1000 cond:4 Ra:4 Rd:4 00 Rs:4 offset:10
    code: |
      Rd = Rd + Ra;
      if (condition_passed(cond, condition_flags((int64_t)Rd - Rs))) {
          pc = (pc - 4) + 2 * sign_extend_10(offset);
      }
  - name: addcmpb<cond> Rd, imm, Rs, 2*offset + pc
    pattern: 1000 cond:4 imm:4 Rd:4 01 Rs:4 offset:10
    code: |
      Rd = Rd + sign_extend_4(imm);
      if (condition_passed(cond, condition_flags((int64_t)Rd - Rs))) {
          pc = (pc - 4) + 2 * sign_extend_10(offset);
      }
  - name: addcmpb<cond> Rd, Ra, imm, 2*offset + pc
    pattern: 1000 cond:4 Ra:4 Rd:4 10 imm:6 offset:8
    code: |
      Rd = Rd + Ra;
      if (condition_passed(cond, condition_flags((int64_t)Rd -  sign_extend_6(imm)))) {
          pc = (pc - 4) + 2 * sign_extend_8(offset);
      }
  - name: addcmpb<cond> Rd, imm1, imm2, 2*offset + pc
    pattern: 1000 cond:4 imm1:4 Rd:4 11 imm2:6 offset:8
    code: |
      Rd = Rd + sign_extend_4(imm1);
      if (condition_passed(cond, condition_flags((int64_t)Rd - sign_extend_6(imm2)))) {
          pc = (pc - 4) + 2 * sign_extend_8(offset);
      }
  - name: b<cond> 2*offset + pc
    pattern: 1001 cond:4 0 offset:23
    code: |
      if (condition_passed(cond, sr)) {
          pc = (pc - 4) + 2 * sign_extend_23(offset);
      }
  - name: bl 2*offset + pc
    pattern: 1001 offset1:4 1 offset2:23
    code: |
      lr = pc + 4;
      pc = (pc - 4) + 2 * ((sign_extend_4(offset1) << 23) | offset2);

  # 32-bit load/store instructions
  - name: ld<size><cond> Rd, (Ra, Rb)
    pattern: 1010 0000 format:2 0 Rd:5 Ra:5 cond:4 00 Rb:5
    desc: |
      Imagine some text about load with scaled indexed address mode here.
    format: ld%s{format}%s{cond} r%i{Rd}, (r%i{Ra}, r%i{Rb})
    code: |
      if (condition_passed(cond, sr)) {
          if (&Ra == &pc) {
              /* TODO: this should be a normal interrupt */
              error("tried to modifiy pc");
          } else {
              Rd = load(Ra + size(format) * Rb, format);
          }
      }
  - name: st<size><cond> Rd, (Ra, Rb)
    pattern: 1010 0000 format:2 1 Rd:5 Ra:5 cond:4 00 Rb:5
    code: |
      if (condition_passed(cond, sr)) {
          store(Ra + size(format) * Rb, format, Rd);
      }
  - name: ld<size><cond> Rd, imm(Ra)
    pattern: 1010 0000 format:2 0 Rd:5 Ra:5 cond:4 10 imm:5
    code: |
      if (condition_passed(cond, sr)) {
          Rd = load(Ra + imm, format);
      }
  - name: st<size><cond> Rd, imm(Ra)
    pattern: 1010 0000 format:2 1 Rd:5 Ra:5 cond:4 10 imm:5
    code: |
      if (condition_passed(cond, sr)) {
          store(Ra + imm, format, Rd);
      }
  - name: ld<size> Rd, offset(Rs)
    pattern: 1010 001 offset1:1 format:2 0 Rd:5 Rs:5 offset2:11
    code: |
      Rd = load(Rs + ((sign_extend_1(offset1) << 11) | offset2), format);
  - name: st<size> Rd, offset(Rs)
    pattern: 1010 001 offset1:1 format:2 1 Rd:5 Rs:5 offset2:11
    code: |
      store(Rs + ((sign_extend_1(offset1) << 11) | offset2), format, Rd);
  - name: ld<size><cond> Rd, --(Ra)
    pattern: 1010 0100 format:2 0 Rd:5 Ra:5 cond:4 000 0000
    code: |
      if (condition_passed(cond, sr)) {
          Ra = Ra - size(format);
          Rd = load(Ra, format);
      }
  - name: st<size><cond> Rd, --(Ra)
    pattern: 1010 0100 format:2 1 Rd:5 Ra:5 cond:4 000 0000
    code: |
      if (condition_passed(cond, sr)) {
          Ra = Ra - size(format);
          store(Ra, format, Rd);
      }
  - name: ld<size><cond> Rd, (Ra)++
    pattern: 1010 0101 format:2 0 Rd:5 Ra:5 cond:4 000 0000
    code: |
      if (condition_passed(cond, sr)) {
          Rd = load(Ra, format);
          Ra = Ra + size(format);
      }
  - name: st<size><cond> Rd, (Ra)++
    pattern: 1010 0101 format:2 1 Rd:5 Ra:5 cond:4 000 0000
    code: |
      if (condition_passed(cond, sr)) {
          store(Ra, format, Rd);
          Ra = Ra + size(format);
      }
  - name: ld<size> Rd, offset(Rs)
    pattern: 1010 10 base:2 format:2 0 Rd:5 offset:16
    code: |
      int base_reg[] = {24, 25, 31, 0};
      Rd = load(regs[base_reg[base]] + sign_extend_16(offset), format);
  - name: st<size> Rd, offset(Rs)
    pattern: 1010 10 base:2 format:2 1 Rd:5 offset:16
    code: |
      int base_reg[] = {24, 25, 31, 0};
      store(regs[base_reg[base]] + sign_extend_16(offset), format, Rd);

  # 32-bit arithmetic instructions
  - name: <op> Rd, imm
    pattern: 1011 00 op:5 Rd:5 imm:16
    code: |
      scalar_op(op, &Rd, Rd, sign_extend_16(imm));
  - name: lea Rd, offset(Rs)
    pattern: 1011 01 Rs:5 Rd:5 offset:16
    code: |
      Rd = Rs + sign_extend_16(offset);
  - name: lea Rd, offset(pc)
    pattern: 1011 1111 111 Rd:5 offset:16
    code: |
      Rd = pc + sign_extend_16(offset);
  - name: <op><cond> Rd, Ra, Rb
    pattern: 1100 00 op:5 Rd:5 Ra:5 cond:4 00 Rb:5
    code: |
      if (condition_passed(cond, sr)) {
        scalar_op(op, &Rd, Ra, Rb);
      }
  - name: <op><cond> Rd, Ra, imm
    pattern: 1100 00 op:5 Rd:5 Ra:5 cond:4 1 imm:6
    code: |
      if (condition_passed(cond, sr)) {
        scalar_op(op, &Rd, Ra, sign_extend_6(imm));
      }

  # mulhd variants
  - name: mulhd<u/s><u/s><cond> Rd, Ra, Rb 
    pattern: 1100 0100 0 unsigned1:1 unsigned2:1 Rd:5 Ra:5 cond:4 00 Rb:5
    code: |
      if (condition_passed(cond, sr)) {
          if (unsigned1 && unsigned2) {
              Rd = (to_uint64(Ra) * to_uint64(Rb)) >> 32;
          } else if (unsigned1) {
              Rd = (to_uint64(Ra) * to_int64(Rb)) >> 32;
          } else if (unsigned2) {
              Rd = (to_int64(Ra) * to_uint64(Rb)) >> 32;
          } else {
              Rd = (to_int64(Ra) * to_int64(Rb)) >> 32;
          }
      }
  - name: mulhd<u/s><u/s><cond> Rd, Ra, imm 
    pattern: 1100 0100 0 unsigned1:1 unsigned2:1 Rd:5 Ra:5 cond:4 1 imm:6
    code: |
      if (condition_passed(cond, sr)) {
          if (unsigned1 && unsigned2) {
              Rd = (to_uint64(Ra) * (to_uint64(sign_extend_6(imm)) & 0xffffffff)) >> 32;
          } else if (unsigned1) {
              Rd = (to_uint64(Ra) * to_int64(sign_extend_6(imm))) >> 32;
          } else if (unsigned2) {
              Rd = (to_int64(Ra) * (to_uint64(sign_extend_6(imm)) & 0xffffffff)) >> 32;
          } else {
              Rd = (to_int64(Ra) * to_int64(sign_extend_6(imm))) >> 32;
          }
      }
  # div variants
  - name: div<u/s><u/s><cond> Rd, Ra, Rb 
    pattern: 1100 0100 1 unsigned1:1 unsigned2:1 Rd:5 Ra:5 cond:4 00 Rb:5
    code: |
      if (condition_passed(cond, sr)) {
          if (unsigned1 && unsigned2) {
              Rd = to_uint64(Ra) / to_uint64(Rb);
          } else if (unsigned1) {
              Rd = to_uint64(Ra) / to_int64(Rb);
          } else if (unsigned2) {
              Rd = to_int64(Ra) / to_uint64(Rb);
          } else {
              Rd = to_int64(Ra) / to_int64(Rb);
          }
      }
  - name: div<u/s><u/s><cond> Rd, Ra, imm 
    pattern: 1100 0100 1 unsigned1:1 unsigned2:1 Rd:5 Ra:5 cond:4 1 imm:6
    code: |
      if (condition_passed(cond, sr)) {
          if (unsigned1 && unsigned2) {
              Rd = to_uint64(Ra) / sign_extend_6(imm);
          } else if (unsigned1) {
              Rd = to_uint64(Ra) / to_int64(sign_extend_6(imm));
          } else if (unsigned2) {
              Rd = to_int64(Ra) / sign_extend_6(imm);
          } else {
              Rd = to_int64(Ra) / to_int64(sign_extend_6(imm));
          }
      }
  - name: add<cond> Rd, Ra, Rb shl 8 
    pattern: 1100 0101 111 Rd:5 Ra:5 cond:4 00 Rb:5
    code: |
      if (condition_passed(cond, sr)) {
          Rd = Ra + (Rb << 8);
      }

  # floating point instructions
  - name: <fop><cond> Rd, Ra, Rb
    pattern: 1100 100 fop:4 Rd:5 Ra:5 cond:4 00 Rb:5
    code: |
      if (condition_passed(cond, sr)) {
        float_op(fop, (float*)&Rd, *(float*)&Ra, *(float*)&Rb);
      }
  - name: <fop><cond> Rd, Ra, imm
    pattern: 1100 100 fop:4 Rd:5 Ra:5 cond:4 1 imm:6
    code: |
      if (condition_passed(cond, sr)) {
        uint32_t b = 0;
        if (imm & 0x20) {
            b |= 0x80000000;
        }
        int exponent = (imm >> 2) & 0x7;
        if (exponent != 0) {
            b |= (exponent + 124) << 23;
            int mantissa = imm & 0x3;
            b |= mantissa << 21;
        }
        float_op(fop, (float*)&Rd, *(float*)&Ra, *(float*)&b);
      }
  - name: ftrunc<cond> Rd, Ra, lsl imm
    pattern: 1100 1010 000 Rd:5 Ra:5 cond:4 1 imm:6
    code: |
      if (condition_passed(cond, sr)) {
        error("TBD");
      }
  - name: floor<cond> Rd, Ra, lsl imm
    pattern: 1100 1010 001 Rd:5 Ra:5 cond:4 1 imm:6
    code: |
      if (condition_passed(cond, sr)) {
        error("TBD");
      }
  - name: flts<cond> Rd, Ra, lsr imm
    pattern: 1100 1010 010 Rd:5 Ra:5 cond:4 1 imm:6
    code: |
      if (condition_passed(cond, sr)) {
        error("TBD");
      }
  - name: fltu<cond> Rd, Ra, lsr imm
    pattern: 1100 1010 011 Rd:5 Ra:5 cond:4 1 imm:6
    code: |
      if (condition_passed(cond, sr)) {
        error("TBD");
      }

  # 48-bit scalar instructions
  - name: lea Rd, offset(pc)
    pattern: 1110 0101 000 Rd:5 offset1:16 offset2:16
    code: |
      Rd = pc + (offset2 << 16) + offset1;
  - name: ld Rd, offset(Rs)
    pattern: 1110 0110 format:2 0 Rd:5 offset1:16 Rs:5 offset2:11
    code: |
      Rd = load(Rs + (offset2 << 16) + offset1, format);
  - name: st Rd, offset(Rs)
    pattern: 1110 0110 format:2 1 Rd:5 offset1:16 Rs:5 offset2:11
    code: |
      store(Rs + (offset2 << 16) + offset1, format, Rd);
  - name: ld Rd, offset(Rs)
    pattern: 1110 0111 format:2 0 Rd:5 offset1:16 11111 offset2:11
    code: |
      Rd = load(pc + (offset2 << 16) + offset1, format);
  - name: st Rd, offset(Rs)
    pattern: 1110 0111 format:2 1 Rd:5 offset1:16 11111 offset2:11
    code: |
      store(pc + (offset2 << 16) + offset1, format, Rd);
  - name: <op> Rd, imm
    pattern: 1110 10 op:5 Rd:5 imm1:16 imm2:16
    code: |
      scalar_op(op, &Rd, Rd, (imm2 << 16) | imm1);
  - name: add Rd, Rs, imm
    pattern: 1110 11 Rs:5 Rd:5 imm1:16 imm2:16
    code: |
      Rd = Rs + ((imm2 << 16) | imm1);
